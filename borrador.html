<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Magic Eraser Pro</title>
    
    <!-- React & Tailwind -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Iconos Phosphor -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        /* Base y Reset */
        body, html {
            background-color: #09090b; /* Zinc-950 */
            color: #fff;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* El scroll lo maneja el canvas logic internamente */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            -webkit-font-smoothing: antialiased;
        }

        /* Canvas Background Pattern */
        .checkered-bg {
            background-color: #18181b;
            background-image: 
                linear-gradient(45deg, #27272a 25%, transparent 25%),
                linear-gradient(-45deg, #27272a 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #27272a 75%),
                linear-gradient(-45deg, transparent 75%, #27272a 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        /* Custom Range Slider */
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #fff;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            margin-top: -8px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #52525b;
            border-radius: 2px;
        }

        /* Animations */
        @keyframes pulse-ring {
            0% { transform: scale(0.8); opacity: 0.5; }
            100% { transform: scale(1.2); opacity: 0; }
        }
        .animate-pulse-ring {
            animation: pulse-ring 2s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
        }
    </style>
</head>
<body>
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        // --- COMPONENTE PRINCIPAL ---
        const App = () => {
            // Estados de la imagen
            const [originalImage, setOriginalImage] = useState(null); // Imagen full resolución
            const [displayImage, setDisplayImage] = useState(null);   // Imagen optimizada para ver en pantalla
            const [imageName, setImageName] = useState("imagen-editada");
            const [fileType, setFileType] = useState("image/png");

            // Estados de la UI
            const [mode, setMode] = useState('PAN'); // 'PAN' (Mover/Zoom) o 'DRAW' (Pintar)
            const [brushSize, setBrushSize] = useState(30);
            const [isProcessing, setIsProcessing] = useState(false);
            const [showOriginal, setShowOriginal] = useState(false);
            
            // Transformaciones (Zoom/Pan)
            const [transform, setTransform] = useState({ x: 0, y: 0, scale: 1 });
            
            // Referencias Canvas
            const containerRef = useRef(null);
            const canvasRef = useRef(null);      // Muestra la imagen
            const maskCanvasRef = useRef(null);  // Donde dibujamos el rojo
            
            // Historia para Deshacer
            const [history, setHistory] = useState([]);

            // --- 1. CARGA DE IMAGEN (Optimización + Guardado de Original) ---
            const handleFile = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                setImageName(file.name.split('.')[0]);
                setFileType(file.type);
                setIsProcessing(true);

                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                        setOriginalImage(img);
                        
                        // Calcular escala inicial para que quepa en pantalla
                        const viewportW = window.innerWidth;
                        const viewportH = window.innerHeight;
                        const scale = Math.min(
                            (viewportW * 0.9) / img.width,
                            (viewportH * 0.8) / img.height
                        );
                        
                        setTransform({
                            x: (viewportW - img.width * scale) / 2,
                            y: (viewportH - img.height * scale) / 2,
                            scale: scale
                        });

                        setIsProcessing(false);
                        setMode('DRAW'); // Cambiar a pintar automáticamente
                    };
                    img.src = ev.target.result;
                };
                reader.readAsDataURL(file);
            };

            // --- 2. GESTIÓN DEL DIBUJO Y TOUCH ---
            const lastPos = useRef(null);
            const lastDist = useRef(null);

            const getCanvasPoint = (clientX, clientY) => {
                // Convierte coordenadas de pantalla a coordenadas de la imagen
                if (!originalImage) return { x: 0, y: 0 };
                return {
                    x: (clientX - transform.x) / transform.scale,
                    y: (clientY - transform.y) / transform.scale
                };
            };

            const handleTouchStart = (e) => {
                if (mode === 'PAN' || e.touches.length === 2) {
                    // Lógica de inicio de Zoom/Pan
                    if (e.touches.length === 2) {
                        const dist = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );
                        lastDist.current = dist;
                    } else {
                        lastPos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    }
                } else if (mode === 'DRAW') {
                    // Lógica de inicio de Pintar
                    const point = getCanvasPoint(e.touches[0].clientX, e.touches[0].clientY);
                    const ctx = maskCanvasRef.current.getContext('2d');
                    
                    // Guardar estado para deshacer (snapshot del canvas de mascara)
                    const w = maskCanvasRef.current.width;
                    const h = maskCanvasRef.current.height;
                    setHistory(prev => [...prev.slice(-5), ctx.getImageData(0, 0, w, h)]);

                    ctx.beginPath();
                    ctx.moveTo(point.x, point.y);
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.lineWidth = brushSize / transform.scale; // Ajustar pincel al zoom
                    ctx.strokeStyle = 'rgba(239, 68, 68, 0.6)'; // Rojo
                    lastPos.current = point;
                }
            };

            const handleTouchMove = (e) => {
                if (!originalImage) return;
                e.preventDefault(); // Evitar scroll del navegador

                if (mode === 'PAN' || e.touches.length === 2) {
                    // MOVER / ZOOM
                    if (e.touches.length === 2) {
                        // Pinch to Zoom simple
                        const dist = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );
                        if (lastDist.current) {
                            const delta = dist / lastDist.current;
                            setTransform(prev => ({ ...prev, scale: Math.max(0.1, Math.min(5, prev.scale * delta)) }));
                        }
                        lastDist.current = dist;
                    } else if (lastPos.current) {
                        // Pan
                        const dx = e.touches[0].clientX - lastPos.current.x;
                        const dy = e.touches[0].clientY - lastPos.current.y;
                        setTransform(prev => ({ ...prev, x: prev.x + dx, y: prev.y + dy }));
                        lastPos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    }
                } else if (mode === 'DRAW') {
                    // PINTAR
                    const point = getCanvasPoint(e.touches[0].clientX, e.touches[0].clientY);
                    const ctx = maskCanvasRef.current.getContext('2d');
                    
                    ctx.lineTo(point.x, point.y);
                    ctx.stroke();
                    lastPos.current = point;
                }
            };

            const handleTouchEnd = () => {
                lastPos.current = null;
                lastDist.current = null;
            };

            // --- 3. ALGORITMO DE BORRADO (Optimizado con Bounding Box) ---
            const performInpainting = async () => {
                if (!originalImage || isProcessing) return;
                setIsProcessing(true);

                // Esperar a que la UI se actualice
                await new Promise(r => setTimeout(r, 50));

                const mainCtx = canvasRef.current.getContext('2d');
                const maskCtx = maskCanvasRef.current.getContext('2d');
                const w = canvasRef.current.width;
                const h = canvasRef.current.height;

                // 1. Obtener datos
                const imgData = mainCtx.getImageData(0, 0, w, h);
                const maskData = maskCtx.getImageData(0, 0, w, h);
                const data = imgData.data;     // Pixeles imagen
                const mData = maskData.data;   // Pixeles mascara (rojo)

                // 2. Encontrar Bounding Box (Solo procesar el área afectada)
                let minX = w, minY = h, maxX = 0, maxY = 0;
                let hasMask = false;

                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const idx = (y * w + x) * 4;
                        if (mData[idx + 3] > 0) { // Si hay algo dibujado
                            if (x < minX) minX = x;
                            if (x > maxX) maxX = x;
                            if (y < minY) minY = y;
                            if (y > maxY) maxY = y;
                            hasMask = true;
                        }
                    }
                }

                if (!hasMask) { setIsProcessing(false); return; }

                // Expandir un poco el área de trabajo para tener contexto
                const padding = 20;
                minX = Math.max(0, minX - padding);
                minY = Math.max(0, minY - padding);
                maxX = Math.min(w - 1, maxX + padding);
                maxY = Math.min(h - 1, maxY + padding);

                const boxW = maxX - minX;
                const boxH = maxY - minY;

                // 3. Algoritmo Simple de Difusión (Blur + Noise filling) 
                // para simular inpainting rápido en JS
                // Nota: Un inpainting real tipo Photoshop requiere WebAssembly o Servidor.
                // Esta es una aproximación "Telea" simplificada.
                
                const pixelsToFill = [];
                for (let y = minY; y <= maxY; y++) {
                    for (let x = minX; x <= maxX; x++) {
                        const idx = (y * w + x) * 4;
                        // Si es máscara (rojo > 0)
                        if (mData[idx + 3] > 50) {
                            pixelsToFill.push({x, y, idx});
                        }
                    }
                }

                // Barajar pixeles para relleno más orgánico
                pixelsToFill.sort(() => Math.random() - 0.5);

                const getPixel = (x, y) => {
                    if (x<0 || x>=w || y<0 || y>=h) return null;
                    const idx = (y*w + x)*4;
                    // Si es mascara, no sirve como fuente
                    if (mData[idx+3] > 50) return null; 
                    return [data[idx], data[idx+1], data[idx+2]];
                };

                // Pasadas de relleno
                pixelsToFill.forEach(p => {
                    let r=0, g=0, b=0, count=0;
                    const radius = 5; // Radio de búsqueda
                    
                    for(let dy=-radius; dy<=radius; dy++){
                        for(let dx=-radius; dx<=radius; dx++){
                            const color = getPixel(p.x + dx, p.y + dy);
                            if(color) {
                                r += color[0]; g += color[1]; b += color[2];
                                count++;
                            }
                        }
                    }

                    if(count > 0) {
                        data[p.idx] = r/count;
                        data[p.idx+1] = g/count;
                        data[p.idx+2] = b/count;
                        // Ruido sutil para textura
                        const noise = (Math.random() - 0.5) * 10;
                        data[p.idx] = Math.min(255, Math.max(0, data[p.idx] + noise));
                        data[p.idx+1] = Math.min(255, Math.max(0, data[p.idx+1] + noise));
                        data[p.idx+2] = Math.min(255, Math.max(0, data[p.idx+2] + noise));
                        
                        // Actualizar máscara para que este pixel sirva a otros
                        mData[p.idx+3] = 0; 
                    }
                });

                // Aplicar cambios
                mainCtx.putImageData(imgData, 0, 0);
                maskCtx.clearRect(0, 0, w, h);
                
                // Actualizar la imagen origen en memoria para futuras ediciones o descargas
                const newImg = new Image();
                newImg.onload = () => {
                    setOriginalImage(newImg);
                    setIsProcessing(false);
                };
                newImg.src = canvasRef.current.toDataURL(fileType); // Mantiene calidad actual
            };

            const handleDownload = () => {
                if (!originalImage) return;
                const link = document.createElement('a');
                link.download = `${imageName}_editada.png`;
                // Exportar canvas actual (que tiene la resolución de la imagen original)
                link.href = canvasRef.current.toDataURL(fileType, 1.0); 
                link.click();
            };

            const handleUndo = () => {
                if (history.length === 0) return;
                const lastMaskState = history[history.length - 1];
                const ctx = maskCanvasRef.current.getContext('2d');
                ctx.putImageData(lastMaskState, 0, 0);
                setHistory(prev => prev.slice(0, -1));
            };

            // --- EFECTOS ---
            // Renderizado inicial y actualizaciones
            useEffect(() => {
                if (originalImage && canvasRef.current && maskCanvasRef.current) {
                    canvasRef.current.width = originalImage.width;
                    canvasRef.current.height = originalImage.height;
                    maskCanvasRef.current.width = originalImage.width;
                    maskCanvasRef.current.height = originalImage.height;

                    const ctx = canvasRef.current.getContext('2d');
                    ctx.drawImage(originalImage, 0, 0);
                }
            }, [originalImage]);


            // --- UI RENDER ---
            if (!originalImage) {
                return (
                    <div className="h-full flex flex-col items-center justify-center bg-zinc-950 text-white p-6 text-center">
                        <div className="w-24 h-24 bg-zinc-900 rounded-3xl flex items-center justify-center mb-6 border border-zinc-800 shadow-2xl animate-pulse-ring relative">
                            <i className="ph ph-magic-wand text-4xl text-indigo-500 relative z-10"></i>
                        </div>
                        <h1 className="text-2xl font-bold mb-2">Editor de Objetos</h1>
                        <p className="text-zinc-400 mb-8 max-w-xs">Sube una foto, marca lo que quieres borrar y la IA lo rellenará.</p>
                        
                        <label className="bg-indigo-600 hover:bg-indigo-500 text-white px-8 py-4 rounded-full font-medium cursor-pointer transition-all active:scale-95 flex items-center gap-2 shadow-lg shadow-indigo-900/50">
                            <i className="ph ph-upload-simple text-xl"></i>
                            <span>Subir Imagen</span>
                            <input type="file" accept="image/*" onChange={handleFile} className="hidden" />
                        </label>
                    </div>
                );
            }

            return (
                <div className="h-full w-full relative checkered-bg overflow-hidden select-none"
                     onTouchStart={handleTouchStart}
                     onTouchMove={handleTouchMove}
                     onTouchEnd={handleTouchEnd}
                >
                    {/* CANVAS CONTAINER */}
                    <div 
                        className="absolute origin-top-left transition-transform duration-75 ease-out will-change-transform"
                        style={{ 
                            transform: `translate(${transform.x}px, ${transform.y}px) scale(${transform.scale})`,
                            width: originalImage.width,
                            height: originalImage.height
                        }}
                    >
                        <canvas ref={canvasRef} className="absolute top-0 left-0" />
                        
                        {/* Capa de Mascara (visible solo si no estamos previsualizando original) */}
                        <canvas 
                            ref={maskCanvasRef} 
                            className={`absolute top-0 left-0 transition-opacity duration-200 ${showOriginal ? 'opacity-0' : 'opacity-100'}`}
                        />
                    </div>

                    {/* --- HEADER FLOTANTE --- */}
                    <div className="absolute top-0 left-0 right-0 p-4 flex justify-between items-start bg-gradient-to-b from-black/80 to-transparent pointer-events-none">
                        <button 
                            onClick={() => {setOriginalImage(null); setTransform({x:0, y:0, scale:1})}} 
                            className="pointer-events-auto w-10 h-10 bg-zinc-800/80 backdrop-blur rounded-full flex items-center justify-center text-white border border-white/10 active:bg-zinc-700"
                        >
                            <i className="ph ph-x text-lg"></i>
                        </button>

                        <div className="flex gap-3 pointer-events-auto">
                            <button 
                                onClick={handleUndo} 
                                disabled={history.length === 0}
                                className={`w-10 h-10 bg-zinc-800/80 backdrop-blur rounded-full flex items-center justify-center text-white border border-white/10 ${history.length===0 ? 'opacity-50' : 'active:bg-zinc-700'}`}
                            >
                                <i className="ph ph-arrow-u-up-left text-lg"></i>
                            </button>
                            <button 
                                onClick={handleDownload}
                                className="w-10 h-10 bg-zinc-800/80 backdrop-blur rounded-full flex items-center justify-center text-white border border-white/10 active:bg-zinc-700"
                            >
                                <i className="ph ph-download-simple text-lg"></i>
                            </button>
                        </div>
                    </div>

                    {/* --- CONTROLES INFERIORES --- */}
                    <div className="absolute bottom-0 left-0 right-0 p-5 pb-8 bg-zinc-950/90 backdrop-blur-md border-t border-white/10 flex flex-col gap-4 rounded-t-3xl">
                        
                        {/* SLIDER TAMAÑO (Solo visible en modo DRAW) */}
                        {mode === 'DRAW' && (
                            <div className="flex items-center gap-4 px-2">
                                <span className="text-xs font-bold text-zinc-500">TAMAÑO</span>
                                <input 
                                    type="range" 
                                    min="10" max="200" 
                                    value={brushSize} 
                                    onChange={(e) => setBrushSize(Number(e.target.value))}
                                    className="flex-1"
                                />
                                <div className="w-6 h-6 rounded-full bg-white border border-zinc-500" style={{ transform: `scale(${brushSize/100 + 0.5})` }}></div>
                            </div>
                        )}

                        <div className="flex justify-between items-center">
                            
                            {/* TOGGLE MODO */}
                            <div className="flex bg-zinc-800/50 p-1 rounded-2xl border border-white/5">
                                <button 
                                    onClick={() => setMode('PAN')}
                                    className={`px-4 py-2 rounded-xl flex flex-col items-center gap-1 transition-all ${mode === 'PAN' ? 'bg-zinc-700 text-white shadow-lg' : 'text-zinc-500'}`}
                                >
                                    <i className="ph ph-hand-grabbing text-xl"></i>
                                    <span className="text-[10px] font-bold">MOVER</span>
                                </button>
                                <button 
                                    onClick={() => setMode('DRAW')}
                                    className={`px-4 py-2 rounded-xl flex flex-col items-center gap-1 transition-all ${mode === 'DRAW' ? 'bg-indigo-600 text-white shadow-lg shadow-indigo-900/50' : 'text-zinc-500'}`}
                                >
                                    <i className="ph ph-paint-brush-broad text-xl"></i>
                                    <span className="text-[10px] font-bold">PINTAR</span>
                                </button>
                            </div>

                            {/* BOTÓN MAGIA */}
                            <button 
                                onClick={performInpainting}
                                disabled={isProcessing}
                                className="relative group bg-white text-black px-6 py-3 rounded-2xl font-bold flex items-center gap-2 active:scale-95 transition-transform"
                            >
                                {isProcessing ? (
                                    <>
                                        <div className="w-5 h-5 border-2 border-black border-t-transparent rounded-full animate-spin"></div>
                                        <span>...</span>
                                    </>
                                ) : (
                                    <>
                                        <i className="ph ph-sparkle text-xl text-indigo-600"></i>
                                        <span>BORRAR</span>
                                    </>
                                )}
                            </button>
                        </div>
                    </div>

                    {/* BOTÓN "VER ORIGINAL" */}
                    <button 
                        className="absolute bottom-32 right-4 w-12 h-12 bg-white/10 backdrop-blur rounded-full border border-white/20 flex items-center justify-center text-white active:bg-white/20 transition-colors"
                        onTouchStart={() => setShowOriginal(true)}
                        onMouseDown={() => setShowOriginal(true)}
                        onTouchEnd={() => setShowOriginal(false)}
                        onMouseUp={() => setShowOriginal(false)}
                        title="Mantener para ver original"
                    >
                        <i className="ph ph-eye text-xl"></i>
                    </button>
                    
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
